<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>GPc by SheffieldML</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>GPc</h1>
        <p>Gaussian process code in C++ including some implementations of GP-LVM and IVM.</p>

        <p class="view"><a href="https://github.com/SheffieldML/GPc">View the Project on GitHub <small>SheffieldML/GPc</small></a></p>


        <ul>
          <li><a href="https://github.com/SheffieldML/GPc/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/SheffieldML/GPc/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/SheffieldML/GPc">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="gpc" class="anchor" href="#gpc" aria-hidden="true"><span class="octicon octicon-link"></span></a>GPc</h1>

<p>Gaussian process code in C++ including some implementations of GP-LVM and IVM.</p>

<h1>
<a id="gaussian-process-software" class="anchor" href="#gaussian-process-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gaussian Process Software</h1>

<p>This page describes how to compile and gives some examples of use of the C++ Gaussian Process code. </p>

<h3>
<a id="release-information" class="anchor" href="#release-information" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release Information</h3>

<p>Current release is 0.001.</p>

<h3>
<a id="design-philosophy" class="anchor" href="#design-philosophy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Philosophy</h3>

<p>The software is written in C++ to try and get a degree of flexibility in the models that can be used without a serious performance hit. This was difficult to do in MATLAB as users who have tried version 1 (which was fast but inflexible) and version 2 (which was flexible but slow) of the MATLAB software will appreciate.</p>

<p>The software is mainly written in C++ but relies for some functions on FORTRAN code by other authors and the LAPACK and BLAS libraries. </p>

<p>As well as the C++ code some utilities are supplied in the corresponding MATLAB code for visualising the results. </p>

<h2>
<a id="compiling-the-software" class="anchor" href="#compiling-the-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiling the Software</h2>

<p>The software was written with gcc on ubuntu.</p>

<p>Part of the reason for using gcc is the ease of interoperability with FORTRAN. The code base makes fairly extensive use of FORTRAN so you need to have g77 installed.
The software is compiled by writing </p>

<div class="highlight highlight-sh"><pre>$ make gp</pre></div>

<p>at the command line. Architecture specific options are included in the <code>make.ARCHITECTURE</code> files. Rename the file with the relevant architecture to <code>make.inc</code> for it to be included.</p>

<h3>
<a id="optimisation" class="anchor" href="#optimisation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optimisation</h3>

<p>One of the advantages of interfacing to the LAPACK and BLAS libraries is that they are often optimised for particular architectures. </p>

<h2>
<a id="general-information" class="anchor" href="#general-information" aria-hidden="true"><span class="octicon octicon-link"></span></a>General Information</h2>

<p>The way the software operates is through the command line. There is one executable, <code>gp</code>. Help can be obtained by writing </p>

<div class="highlight highlight-sh"><pre>$ ./gp -h</pre></div>

<p>which lists the commands available under the software. Help for each command can then be obtained by writing, for example, </p>

<div class="highlight highlight-sh"><pre>$ ./gp learn -h</pre></div>

<p>All the tutorial optimisations suggested take less than 1/2 hour to run on my less than 2GHz Pentium IV machine. The first oil example runs in a couple of minutes. Below I suggest using the highest verbosity options <code>-v 3</code> in each of the examples so that you can track the iterations.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<p>The software loads in data in the <a href="http://svmlight.joachims.org/">SVM light</a> format. This is to provide compatibility with other <a href="https://github.com/SheffieldML/GPmat/">Gaussian Process software</a>. Anton Schwaighofer has written <a href="http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/software/svml_toolbox.html"> a package</a> which can write from MATLAB to the SVM light format.</p>

<h2>
<a id="one-dimensional-data-data" class="anchor" href="#one-dimensional-data-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>One Dimensional Data Data</h2>

<p>Provided with the software, in the <code>examples</code> directory, is a one dimensional regression problem. The file is called <code>spgp1d.svml</code>. </p>

<p>First we will learn the data using the following command,</p>

<div class="highlight highlight-sh"><pre>$ ./gp -v 3 learn -# 100 examples/sinc.svml sinc.model</pre></div>

<p>The flag <code>-v 3</code> sets the verbosity level to 3 (the highest level) which causes the iterations of the scaled conjugate gradient algorithm to be shown. The flag <code>-# 100</code> terminates the optimisation after 100 iterations so that you can quickly move on with the rest of the tutorial.</p>

<p>The software will load the data in <code>sinc.svml</code>. The labels are included in this file but they are <i>not</i> used in the optimisation of the model. They are for visualisation purposes only.</p>

<h3>
<a id="gnuplot" class="anchor" href="#gnuplot" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gnuplot</h3>

<p>The learned model is saved in a file called <code>sinc.model</code>. This file has a plain text format to make it human readable. Once training is complete, the learned covariance function parameters of the model can be displayed using </p>

<div class="highlight highlight-sh"><pre>$ ./gp display sinc.model</pre></div>

<div class="highlight highlight-sh"><pre>Loading model file.
... <span class="pl-k">done</span>.
Standard GP Model: 
Optimiser: scg
Data Set Size: 40
Kernel Type: 
Scales learnt: 0
X learnt: 0
Bias: 0.106658 

Scale: 1 

Gaussian Noise: 
Bias on process 0: 0
Variance: 1e-06
compound kernel:
rbfinverseWidth: 0.198511
rbfvariance: 0.0751124
biasvariance: 1.6755e-05
whitevariance: 0.00204124</pre></div>

<p>Notice the fact that the covariance function is composed of an RBF kernel, also known as squared exponential kernel or Gaussian kernel; a bias kernel, which is just a constant, and a white noise kernel, which is a diagonal term. This is the default setting, it can be changed with flags to other covariance function types, see <code>./gp learn -h</code> for details.</p>

<p>For your convenience a <code>gnuplot</code> file may generated to visualise the data. First run</p>

<div class="highlight highlight-sh"><pre>$ ./gp gnuplot -r 400 examples/sinc.svml sinc.model sinc</pre></div>

<p>The <code>sinc</code> supplied as the last argument acts as a stub for gnuplot to create names from, so for example (using gnuplot vs 4.0 or above), you can write</p>

<div class="highlight highlight-sh"><pre>$ gnuplot sinc_plot.gp</pre></div>

<p>Note: for this to work on OSX you may have to </p>

<div class="highlight highlight-sh"><pre>$ brew install gnuplot --with-x</pre></div>

<p>Then you should obtain the plot shown below
</p><img src="sinc.png"><br>
Gaussian process applied to sinc data.<br>

<p>The other files created are <code>sinc_error_bar_data.dat</code>, which produces the error bars and <code>sinc_line_data.dat</code> which produces the mean as well as <code>sinc_scatter_data.dat</code> which shows the training data.</p>

<h3>
<a id="other-data" class="anchor" href="#other-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Data</h3>

<p>You might also want to try a larger data set.</p>

<div class="highlight highlight-sh"><pre>$ ./gp -v 3 learn -# 100 examples/spgp1d.svml spgp1d.model</pre></div>

<h3>
<a id="matlab-and-octave" class="anchor" href="#matlab-and-octave" aria-hidden="true"><span class="octicon octicon-link"></span></a>MATLAB and OCTAVE</h3>

<p>While MATLAB can be slow (and very expensive for non-academic users) it can still be a lot easier to code the visualisation routines by building on MATLAB's graphics facilities. To this end you can load in the results from the MATLAB/OCTAVE GPmat toolbox for further manipulation. You can download the toolbox from <a href="https://github.com/SheffieldML/GPmat/">here</a>. Once the relevant toolboxes (you need all the dependent toolboxes) are downloaded you can visualise the results in MATLAB using</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>[y, X] = svmlread(<span class="pl-s"><span class="pl-pds">'</span>sinc.svml<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt; </span>gpReadFromFile(<span class="pl-s"><span class="pl-pds">'</span>sinc.model<span class="pl-pds">'</span></span>, X, y)
<span class="pl-k">&gt;&gt;</span></pre></div>

<p>where we have used the <a href="http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/software/svml_toolbox.html">SVML toolbox</a> of Anton Schwaighofer to load in the data.</p>

<h1>
<a id="ivm-software" class="anchor" href="#ivm-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>IVM Software</h1>

<p>This page describes how to compile and gives some examples of use of the C++ Informative Vector Machine Software (IVM).</p>

<h3>
<a id="design-philosophy-1" class="anchor" href="#design-philosophy-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Philosophy</h3>

<p>The software is written in C++ to try and get a degree of flexibility in the models that can be used without a serious performance hit. </p>

<p>The software is mainly written in C++ but relies for some functions on FORTRAN code by other authors and the LAPACK and BLAS libraries. </p>

<h2>
<a id="compiling-the-software-1" class="anchor" href="#compiling-the-software-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiling the Software</h2>

<p>The software was written with gcc vs 3.2.2. There are definitely Standard Template Library issues on Solaris with gcc 2.95, so I suggest that at least version 3.2 or above is used.</p>

<p>Part of the reason for using gcc is the ease of interoperability with FORTRAN. The code base makes fairly extensive use of FORTRAN so you need to have g77 installed.
The software is compiled by writing </p>

<div class="highlight highlight-sh"><pre>$ make ivm</pre></div>

<p>at the command line. Architecture specific options are included in the <code>make.ARCHITECTURE</code> files. Rename the file with the relevant architecture to <code>make.inc</code> for it to be included.</p>

<h3>
<a id="optimisation-1" class="anchor" href="#optimisation-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optimisation</h3>

<p>One of the advantages of interfacing to the LAPACK and BLAS libraries is that they are often optimised for particular architectures. The file <code>make.atlas</code> includes options for compiling the ATLAS optimised versions of lapack and blas that are available on a server I have access to. These options may vary for particular machines.</p>

<h3>
<a id="cygwin" class="anchor" href="#cygwin" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cygwin</h3>

<p>For Windows users the code compiles under cygwin. However you will need version s of the lapack and blas libraries available (see <a href="http://www.netlib.org">www.netlib.org</a>). This can take some time to compile, and in the absence of any pre-compiled versions on the web I've provided some pre-compiled versions you may want to make use of (see the cygwin directory). Note that these pre-compiled versions are <i>not</i> optimised for the specific architecture and therefore do not give the speed up you would hope for from using lapack and blas.</p>

<h3>
<a id="microsoft-visual-c" class="anchor" href="#microsoft-visual-c" aria-hidden="true"><span class="octicon octicon-link"></span></a>Microsoft Visual C++</h3>

<p>As of Release 0.101 the code compiles under Microsoft Visual Studio 7.1. A project file is provided in the current release in the directory <code>MSVC/ivm</code>. The compilation makes use of f2c versions of the FORTRAN code and the C version of LAPACK/BLAS, CLAPACK. Detailed instructions on how to compile are in the readme.msvc file. Much of the work to convert the code (which included ironing out several bugs) was done by William V. Baxter for the GPLVM code. </p>

<h2>
<a id="general-information-1" class="anchor" href="#general-information-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>General Information</h2>

<p>The way the software operates is through the command line. There is one executable, <code>ivm</code>. Help can be obtained by writing </p>

<div class="highlight highlight-sh"><pre>$ ./ivm -h</pre></div>

<p>which lists the commands available under the software. Help for each command can then be obtained by writing, for example, </p>

<div class="highlight highlight-sh"><pre>$ ./ivm learn -h</pre></div>

<p>All the tutorial optimisations are suggested take less than 1/2 hour to run on my less than 2GHz Pentium IV machine. The first oil example runs in a couple of minutes. Below I suggest using the highest verbosity options <code>-v 3</code> in each of the examples so that you can track the iterations.</p>

<h2>
<a id="bugs" class="anchor" href="#bugs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bugs</h2>

<p>Victor Cheng writes:</p>

<p><i>" ... I've tested your IVM C++ Gaussian Process tool (IVMCPP0p12 version). It is
quite useful. However, the gnuplot function seems has a problem. Every time
I type the command: "Ivm gnuplot traindata name.model", an error comes out
as: "Unknown noise model!". When I test this function with IVMCPP0p11 IVM,
its fine, but IVMCPP0p11 has another problem that it gives "out of memory"
error in test mode! So I use two vesions simultaneously. "</i> </p>

<p>I'm working (as of 31/12/2007) on a major rewrite, so it's unlikely that these bugs will be fixed in the near future, however if anyone makes a fix I'll be happy to incorporate it! Please let me know.</p>

<h2>
<a id="examples-1" class="anchor" href="#examples-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<p>The software loads in data in the <a href="http://svmlight.joachims.org/">SVM light</a> format. Anton Schwaighofer has written <a href="http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/software/svml_toolbox.html"> a package</a> which can write from MATLAB to the SVM light format.</p>

<h2>
<a id="toy-data-sets" class="anchor" href="#toy-data-sets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Toy Data Sets</h2>

<p>In this section we present some simple examples. The results will be visualised using <code>gnuplot</code>. It is suggested that you have access to <code>gnuplot</code> vs 4.0 or above.</p>

<p>Provided with the software, in the <code>examples</code> directory, are some simple two dimensional problems. We will first try classification with these examples.</p>

<p>The first example is data sampled from a Gaussian process with an RBF kernel function with inverse width of 10. The input data is sampled uniformly from the unit square. This data can be learnt with the following command.</p>

<div class="highlight highlight-sh"><pre>$ ./ivm -v 3 learn -a 200 -k rbf examples/unitsquaregp.svml unitsquaregp.model</pre></div>

<p>The flag <code>-v 3</code> sets the verbosity level to 3 (the highest level) which causes the iterations of the scaled conjugate gradient algorithm to be shown. The flag <code>-a 200</code> sets the active set size. The kernel type is selected with the flag <code>-k rbf</code>. </p>

<h3>
<a id="gnuplot-1" class="anchor" href="#gnuplot-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gnuplot</h3>

<p>The learned model is saved in a file called <code>unitsquaregp.model</code>. This file has a plain text format to make it human readable. Once training is complete, the learned kernel parameters of the model can be displayed using </p>

<div class="highlight highlight-sh"><pre>$ ./ivm display unitsquaregp.model</pre></div>

<div class="highlight highlight-sh"><pre>Loading model file.
... <span class="pl-k">done</span>.
IVM Model:
Active Set Size: 200
Kernel Type:
compound kernel:
rbfinverseWidth: 12.1211
rbfvariance: 0.136772
biasvariance: 0.000229177
whitevariance: 0.0784375
Noise Type:
Probit noise:
Bias on process 0: 0.237516</pre></div>

<p>Notice the fact that the kernel is composed of an RBF kernel, also known as squared exponential kernel or Gaussian kernel; a bias kernel, which is just a constant, and a white noise kernel, which is a diagonal term. The bias kernel and the white kernel are automatically added to the rbf kernel. Other kernels may also be used, see <code>ivm learn -h</code> for details.</p>

<p>For this model the input data is two dimensional, you can therefore visualise the decision boundary using</p>

<div class="highlight highlight-sh"><pre>$ ./ivm gnuplot examples/unitsquaregp.svml unitsquaregp.model unitsquaregp</pre></div>

<p>The <code>unitsquaregp</code> supplied as the last argument acts as a stub for gnuplot to create names from, so for example (using gnuplot vs 4.0 or above), you can write</p>

<div class="highlight highlight-sh"><pre>$ gnuplot unitsquaregp_plot.gp</pre></div>

<p>and obtain the plot shown below
</p><img src="unitsquaregp_plot.png"><br>
The decision boundary learnt for the data sampled from a Gaussian process classification. Note the active points (blue stars) typically lie along the decision boundary.<br>

<p>The other files created are <code>oil100_variance_matrix.dat</code>, which produces the grayscale map of the log precisions and <code>oil100_latent_data1-3.dat</code> which are files containing the latent data positions associated with each label.</p>

<h3>
<a id="feature-selection" class="anchor" href="#feature-selection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feature Selection</h3>

<p>Next we consider a simple ARD kernel. The toy data in this case is sampled from three Gaussian distributions. To separate the data only one input dimension is necessary. The command is run as follows,</p>

<div class="highlight highlight-sh"><pre>$ ./ivm learn -a 100 -k rbf -i 1 examples/ard_gaussian_clusters.svml ard_gaussian_clusters.model</pre></div>

<p>Displaying the model it is clear that it has selected one of the input dimensions, </p>

<div class="highlight highlight-sh"><pre>Loading model file.<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
... <span class="pl-k">done</span>.<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
IVM Model:<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
Active Set Size: <span class="pl-k">100&lt;</span>br<span class="pl-k">&gt;</span>
Kernel Type:<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
compound kernel:<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
rbfardinverseWidth: 0.<span class="pl-k">12293&lt;</span>br<span class="pl-k">&gt;</span>
rbfardvariance: 2.<span class="pl-k">25369&lt;</span>br<span class="pl-k">&gt;</span>
rbfardinputScale: 5.88538e-<span class="pl-k">08&lt;</span>br<span class="pl-k">&gt;</span>
rbfardinputScale: 0.<span class="pl-k">935148&lt;</span>br<span class="pl-k">&gt;</span>
biasvariance: 9.10663e-<span class="pl-k">07&lt;</span>br<span class="pl-k">&gt;</span>
whitevariance: 2.75252e-<span class="pl-k">08&lt;</span>br<span class="pl-k">&gt;</span>
Noise Type:<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
Probit noise:<span class="pl-k">&lt;</span>br<span class="pl-k">&gt;</span>
Bias on process 0: 0.745098
</pre></div>

<p>Once again the results can be displayed as a two dimensional plot,</p>

<div class="highlight highlight-sh"><pre>$ ./ivm gnuplot examples/ard_gaussian_clusters.svml ard_gaussian_clusters.model ard_gaussian_clusters</pre></div>

<p></p><img src="ard_gaussian_clusters_plot.png"><br>
The IVM learnt with an ARD RBF kernel. One of the input directions has been recognised as not relevant.


<h2>
<a id="semi-supervised-learning" class="anchor" href="#semi-supervised-learning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Semi-Supervised Learning</h2>

<p>The software also provides an implementation of the null category noise model described in <a href="http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Lawrence:semisuper04">Lawrence and Jordan</a>. </p>

<p>The toy example given in the paper is reconstructed here. To run it type</p>

<div class="highlight highlight-sh"><pre>$ ./ivm learn -a 100 -k rbf examples/semisupercrescent.svml semisupercrescent.model</pre></div>

<p>The result of learning is</p>

<div class="highlight highlight-sh"><pre>Loading model file.
... <span class="pl-k">done</span>.
IVM Model:
Active Set Size: 100
Kernel Type:
compound kernel:
rbfinverseWidth: 0.0716589
rbfvariance: 2.58166
biasvariance: 2.03635e-05
whitevariance: 3.9588e-06
Noise Type:
Ncnm noise:
Bias on process 0: 0.237009
Missing label probability <span class="pl-k">for</span> <span class="pl-smi">-ve</span> class: 0.9075
Missing label probability <span class="pl-k">for</span> <span class="pl-smi">+ve</span> class: 0.9075</pre></div>

<p>and can be visualised using</p>

<div class="highlight highlight-sh"><pre>$ ./ivm gnuplot examples/semisupercrescent.svml semisupercrescent.model semisupercrescent</pre></div>

<p>followed by </p>

<div class="highlight highlight-sh"><pre>$ gnuplot semisupercrescent_plot.gp</pre></div>

<p>The result of the visualisation being,</p>

<p></p><img src="semisupercrescent_plot.png"><img src="semisupercrescent_labels_only_plot.png"><br>The result of semi-supervised learning on the crescent data. At the top is the result from the null category noise model. The bottom shows the result from training only on the labelled data only with the standard probit noise model. Purple squares are unlabelled data, blue stars are the active set. 

<h1>
<a id="gp-lvm-software" class="anchor" href="#gp-lvm-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>GP-LVM Software</h1>

<p>This page describes how to compile and gives some examples of use of the C++ Gaussian Process Latent Variable Model Software (GP-LVM) available for <a href="http://ml.sheffield.ac.uk/~neil/cgi-bin/software/downloadForm.cgi?toolbox=gplvmcpp">download here</a>. </p>

<h3>
<a id="release-information-1" class="anchor" href="#release-information-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release Information</h3>

<h4>
<a id="release-0201" class="anchor" href="#release-0201" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release 0.201</h4>

<p>Fixed bug which meant that back constraint wasn't working due to failure to initialise lwork properly for dsysv. </p>

<p>Fixed bug in gplvm.cpp which meant dynamics wasn't working properly because initialization of dynamics model learning parameter wasn't set to zero.</p>

<p>Thanks to Gustav Henter for pointing out these problems.</p>

<h4>
<a id="release-02" class="anchor" href="#release-02" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release 0.2</h4>

<p>In this release we updated the class structure of the gplvm model and
made some changes in the way in which files are stored. This release
is intended as a stopgap before a release version in which fitc, dtc
and variational dtc approximations will be available.</p>

<p>In this release the dynamics model of <a href="http://www.dgp.toronto.edu/~jmwang/gpdm/">Wang <i>et al</i>.</a> has been included. The initial work was done by William V. Baxter, with modifications by me to include the unusual prior Wang suggests in his MSc thesis, scaling of the dynamics likelihood and the ability to set the signal noise ratio. A new example has been introduced for this model below.</p>

<p>As part of the dynamics introduction a new MATLAB toolbox for the GP-LVM has been released. This toolbox, <a href="http://ml.sheffield.ac.uk/~neil/cgi-bin/software/downloadForm.cgi?toolbox=fgplvm">download here</a>, is expected to be the main development toolbox for the GP-LVM in MATLAB.</p>

<p>Version 0.101 was released 21st October 2005.</p>

<p>This release contained modifications by William V. Baxter to enable the code to work with Visual Studio 7.1.</p>

<p>Version 0.1, was released in late July 2005.</p>

<p>This was the original release of the code.</p>

<h3>
<a id="design-philosophy-2" class="anchor" href="#design-philosophy-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Philosophy</h3>

<p>The software is written in C++ to try and get a degree of
flexibility in the models that can be used without a serious
performance hit. This was difficult to do in MATLAB as users who have
tried version 1 (which was fast but inflexible) and version 2 (which
was flexible but slow) of the MATLAB software will appreciate.</p>

<p>The sparsification algorithm has not been implemented in the C++
software so this software is mainly for smaller data sets (up to
around a thousand points).</p>

<p>The software is mainly written in C++ but relies for some functions
on FORTRAN code by other authors and the LAPACK and BLAS libraries.</p>

<p>As well as the C++ code some utilities are supplied in MATLAB code
for visualising the results.</p>

<h2>
<a id="compiling-the-software-2" class="anchor" href="#compiling-the-software-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compiling the Software</h2>

<p>The software was written with gcc vs 3.2.2. There are definitely
Standard Template Library issues on Solaris with gcc 2.95, so I
suggest that at least version 3.2 or above is used.</p>

<p>Part of the reason for using gcc is the ease of interoperability
with FORTRAN. The code base makes fairly extensive use of FORTRAN so
you need to have g77 installed.  The software is compiled by
writing</p>

<div class="highlight highlight-sh"><pre>$ make gplvm</pre></div>

<p>at the command line. Architecture specific options are included in
the <code>make.ARCHITECTURE</code> files. Rename the file with the
relevant architecture to <code>make.inc</code> for it to be included.</p>

<h3>
<a id="optimisation-2" class="anchor" href="#optimisation-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Optimisation</h3>

<p>One of the advantages of interfacing to the LAPACK and BLAS libraries
is that they are often optimised for particular architectures. The
file <code>make.atlas</code> includes options for compiling the ATLAS
optimised versions of lapack and blas that are available on a server I
have access to. These options may vary for particular machines.</p>

<h3>
<a id="cygwin-1" class="anchor" href="#cygwin-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cygwin</h3>

<p>For Windows users the code compiles under cygwin. However you will
need version s of the lapack and blas libraries available (see <a href="http://www.netlib.org">www.netlib.org</a>. This can take some
time to compile, and in the absence of any pre-compiled versions on
the web I've provided some pre-compiled versions you may want to make
use of (see the cygwin directory). Note that these pre-compiled
versions are <i>not</i> optimised for the specific architecture and
therefore do not give the speed up you would hope for from using
lapack and blas.</p>

<h3>
<a id="microsoft-visual-c-1" class="anchor" href="#microsoft-visual-c-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Microsoft Visual C++</h3>

<p>As of Release 0.101 the code compiles under Microsoft Visual Studio
7.1. A project file is provided in the current release in the
directory <code>MSVC/gplvm</code>. The compilation makes use of f2c
versions of the FORTRAN code and the C version of LAPACK/BLAS,
CLAPACK. Detailed instructions on how to compile are in the
readme.msvc file. The work to convert the code (which included ironing
out several bugs) was done by William V. Baxter. Many thanks to Bill
for allowing me to make this available.</p>

<h2>
<a id="general-information-2" class="anchor" href="#general-information-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>General Information</h2>

<p>The way the software operates is through the command line. There is
one executable, <code>gplvm</code>. Help can be obtained by writing</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm -h</pre></div>

<p>which lists the commands available under the software. Help for
each command can then be obtained by writing, for example,</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm learn -h</pre></div>

<p>All the tutorial optimisations suggested take less than 1/2 hour to
run on my less than 2GHz Pentium IV machine. The first oil example
runs in a couple of minutes. Below I suggest using the highest
verbosity options <code>-v 3</code> in each of the examples so that
you can track the iterations.</p>

<h2>
<a id="examples-2" class="anchor" href="#examples-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<p>The software loads in data in the <a href="http://svmlight.joachims.org/">SVM light</a> format. This is to
provide compatibility with other <a href="https://github.com/SheffieldML/GPmat/">Gaussian
Process software</a>. Anton Schwaighofer has written <a href="http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/software/svml_toolbox.html"> a package</a>
which can write from MATLAB to the SVM light format.</p>

<h2>
<a id="oil-flow-data" class="anchor" href="#oil-flow-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Oil Flow Data</h2>

<p>In the original NIPS paper the first example was the oil flow data
(see <a href="http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/3PhaseData.html">this
page</a> for details) sub-sampled to 100 points. I use this data a lot
for checking the algorithm is working so in some senses it is not an
independent `proof' of the model.</p>

<p>Provided with the software, in the <code>examples</code> directory,
is a sub-sample of the oil data. The file is called
<code>oilTrain100.svml</code>.</p>

<p>First we will learn the data using the following command,</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm -v 3 learn -# 100 examples/oilTrain100.svml oil100.model</pre></div>

<p>The flag <code>-v 3</code> sets the verbosity level to 3 (the
highest level) which causes the iterations of the scaled conjugate
gradient algorithm to be shown. The flag <code>-# 100</code>
terminates the optimisation after 100 iterations so that you can
quickly move on with the rest of the tutorial.</p>

<p>The software will load the data in
<code>oilTrain100.svml</code>. The labels are included in this file
but they are <i>not</i> used in the optimisation of the model. They
are for visualisation purposes only.</p>

<h3>
<a id="gnuplot-2" class="anchor" href="#gnuplot-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gnuplot</h3>

<p>The learned model is saved in a file called
<code>oil100.model</code>. This file has a plain text format to make
it human readable. Once training is complete, the learned kernel
parameters of the model can be displayed using</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm display oil100.model</pre></div>

<div class="highlight highlight-sh"><pre>
Loading model file.
... <span class="pl-k">done</span>.
GPLVM Model:
Data Set Size: 100
Kernel Type:
compound kernel:
rbfinverseWidth: 3.97209
rbfvariance: 0.337566
biasvariance: 0.0393251
whitevariance: 0.00267715</pre></div>

<p>Notice the fact that the kernel is composed of an RBF kernel, also
known as squared exponential kernel or Gaussian kernel; a bias kernel,
which is just a constant, and a white noise kernel, which is a
diagonal term. This is the default setting, it can be changed with
flags to other kernel types, see <code>gplvm learn -h</code> for
details.</p>

<p>For your convenience a <code>gnuplot</code> file may generated to
visualise the data. First run</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm gnuplot oil100.model oil100</pre></div>

<p>The <code>oil100</code> supplied as the last argument acts as a
stub for gnuplot to create names from, so for example (using gnuplot
vs 4.0 or above), you can write</p>

<div class="highlight highlight-sh"><pre>$ gnuplot oil100_plot.gp</pre></div>

<p>And obtain the plot shown below
</p><img src="oil100_plot.png"><br>
Visualisation of 100 points of the oil flow data.<br>

<p>The other files created are
<code>oil100_variance_matrix.dat</code>, which produces the grayscale
map of the log precisions and <code>oil100_latent_data1-3.dat</code>
which are files containing the latent data positions associated with
each label.</p>

<h3>
<a id="the-entire-oil-data-set" class="anchor" href="#the-entire-oil-data-set" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Entire Oil Data Set</h3>

<p>Running the GPLVM for 1000 iterations on all 1000 points of the oil
data leads to the visualisation below.</p>

<p></p><img src="oil1000_plot.png"><br>
All 1000 points of the oil data projected into latent space. This visualisation takes overnight to optimise on a Pentinum IV.


<h3>
<a id="matlab" class="anchor" href="#matlab" aria-hidden="true"><span class="octicon octicon-link"></span></a>MATLAB</h3>

<p>While MATLAB can be horribly slow (and very expensive for non-academic
users) it is still a lot easier (for me) to code the visualisation
routines by building on MATLAB's graphics facilities. To this end a
new release of the GPLVM code in MATLAB has been provided (vs 2.012
and above) which allows you to load the results of the learning from
the C++ code into MATLAB for further manipulation. You can download
the toolbox from <a href="http://ml.sheffield.ac.uk/~neil/cgi-bin/software/downloadForm.cgi?toolbox=gplvm">here</a>. Once
the relevant toolboxes (you need the IVM toolbox and the toolboxes on
which it depends: KERN, NOISE, etc.) are downloaded you can visualise
the results in MATLAB using</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>gplvmResultsCpp(<span class="pl-s"><span class="pl-pds">'</span>oil100.model<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>vector<span class="pl-pds">'</span></span>)
<span class="pl-k">&gt;&gt;</span></pre></div>

<p>This will load the results and allow you to move around the latent
space visualising (in the form of a line plotted from the vector) the
nature of the data at each point.</p>

<h2>
<a id="motion-capture" class="anchor" href="#motion-capture" aria-hidden="true"><span class="octicon octicon-link"></span></a>Motion Capture</h2>

<p>One popular use of the GPLVM has been in learning of human motion
styles (see <a href="http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Grochow:styleik04&amp;printAbstract=1">Grochow
<i>et al.</i></a>). Personally, I find this application very
motivating as Motion Capture data is a rare example of high
dimensional data about which humans have a strong intuition. If the
model fails to model `natural motion' it is quite apparant to a human
observer. Therefore, as a second example, we will look at data of this
type. In particular we will consider a data sets containing a walking
man and a further data set containing a horse. To run these demos you
will also need a small <a href="http://ml.sheffield.ac.uk/~neil/cgi-bin/software/downloadForm.cgi?toolbox=mocap">MATLAB
mocap toolkit</a>.</p>

<h3>
<a id="bvh-files" class="anchor" href="#bvh-files" aria-hidden="true"><span class="octicon octicon-link"></span></a>BVH Files</h3>

<p>To prepare a new bvh file for visualisation you need the MATLAB
mocap toolkit and Anton Schwaighofer's <a href="http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/software/svml_toolbox.html"> SVM light
MATLAB interface</a> (you don't need the SVM light software itself).</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>[bvhStruct, channels, frameLength] = bvhReadFile(<span class="pl-s"><span class="pl-pds">'</span>examples/Swagger.bvh<span class="pl-pds">'</span></span>);
<span class="pl-k">&gt;&gt;</span></pre></div>

<p>This motion capture data was taken from Ohio State University's <a href="http://accad.osu.edu/research/mocap/mocap_data.htm">ACCAD</a>
centre.</p>

<p>The motion capture channels contain values for the offset of the
root node at each frame. If we don't want to model this motion it can
be removed at this stage. Setting the 1st, 3rd and 6th channels to
zero removes X and Z position and the rotation in the Y plane.</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>channels(<span class="pl-k">:</span>, [<span class="pl-c1">1</span> <span class="pl-c1">3</span> <span class="pl-c1">6</span>]) = <span class="pl-k">zeros</span>(<span class="pl-k">size</span>(channels, <span class="pl-c1">1</span>), <span class="pl-c1">3</span>);</pre></div>

<p>You can now play the data using the command</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>bvhPlayData(bvhStruct, channels, frameLength);</pre></div>

<p>Data in the bvh format consists of angles, this presents a problem
when the angle passes through a discontinuity. For example in this
data the 'lhumerus' and 'rhumerus' joints rotate through 180 degrees
and the channel moves from -180 to +180. This arbitrary difference
will seriously effect the results. The fix is to add or subtract 360
as appropriate. In the toolbox provided this is done automatically in
the file bvhReadFile.m using the function channelsAngles. This works
well for the files we use here, but may not be a sufficient solution
for files with more rotation on the joints.</p>

<p>Then channels can be saved for modelling using Schwaighofer's SVM
light interface. First we downsample so that things run quickly,</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>channels = channels(<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">4</span><span class="pl-k">:end</span>,<span class="pl-k"> :</span>);</pre></div>

<p>Then the data is saved as follows:</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>svmlwrite(<span class="pl-s"><span class="pl-pds">'</span>examples/swagger.svml<span class="pl-pds">'</span></span>,channels)</pre></div>

<p><i>Before you save you might want to check you haven't messed
anything up by playing the data again!</i> It makes sense to learn
the scale independently for each the channels (particularly since we
have set three of them to zero!), so we now use the gplvm code to
learn the data setting the flag <code>-L true</code> for learning of
scales.</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm -v 3 learn -L <span class="pl-c1">true</span> examples/swagger.svml swagger.model</pre></div>

<p>Once learning is complete the results can be visualised in MATLAB
using the command</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>mocapResultsCppBvh(<span class="pl-s"><span class="pl-pds">'</span>swagger.model<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>examples/Swagger.bvh<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>bvh<span class="pl-pds">'</span></span>);</pre></div>

<p></p><img src="swagger_plot.png">
<br>Latent space for the Swagger data. Note the breaks in the sequence.

<h3>
<a id="dealing-with-the-breaks" class="anchor" href="#dealing-with-the-breaks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dealing with the Breaks</h3>

<p>Note that there are breaks in the sequence. These reason for these
breaks is as follows. The GPLVM maps from the latent space to the data
space with a smooth mapping. This means that points that are nearby in
latent space will be nearby in data space. However that does not imply
the reverse, i.e. points that are nearby in data space will not
necessarily be nearby in latent space. It implies that if points are
far apart in data space they will be far apart in latent space which
is a slightly different thing. This means that the model is not
strongly penalised for breaking the sequence (even if a better
solution can be found through not breaking the sequence).</p>

<p>For visualisation you often want points being nearby in data space to
be nearby in latent space. For example, most of the recent spectral
techniques (including kernel PCA, Isomap, and LLE) try and guarantee
this. In recent unpublished work with <a href="http://www.kyb.tuebingen.mpg.de/~jqc">Joaquin Quinonero
Candela</a>, we have shown that this can be achieved in the GPLVM
using `back constraints'. We constrain the data in the latent space to
be represented by a second reverse-mapping from the data space. For
the walking man the show results you can test the back constraints
with the command</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm -v 3 learn -L <span class="pl-c1">true</span> -c rbf -g 0.0001 examples/swagger.svml swagger_back_constrained.model</pre></div>

<p>The back constraint here is a kernel mapping with an `RBF' kernel
which is specified as having an inverse width of 1e-4.</p>

<p>The results can then be seen in MATLAB using</p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>mocapResultsCppBvh(<span class="pl-s"><span class="pl-pds">'</span>swagger_back_constrained.model<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>examples/Swagger.bvh<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>bvh<span class="pl-pds">'</span></span>);</pre></div>

<p></p><img src="swagger_back_constrained_plot.png">
<br>The repeated circular pattern is associated with the repeated walking paces in the data.

<h3>
<a id="dealing-with-the-breaks-with-dynamics" class="anchor" href="#dealing-with-the-breaks-with-dynamics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dealing with the Breaks with Dynamics</h3>

<p>It conceptually straightforward to add MAP dynamics in the GP-LVM
latent space by placing a prior that relates the latent points
temporally. There are several ways one could envisage doing this. <a href="http://www.dgp.toronto.edu/~jmwang/gpdm/">Wang <i>et al</i></a>
proposed introducing dynamics through the use of a Gaussian process
mapping across time points. William V. Baxter implemented this
modification to the code and kindly allowed me to make his
modifications available. In the base case adding dynamics associated
with a GP doesn't change things very much: the Gaussian process
mapping is too flexible and doesn't constrain the behaviour of the
model. To solve this problem Wang suggests using a particular prior on
the hyper parameters of the GP-LVM (see pg 58 of his <a href="http://www.dgp.toronto.edu/~jmwang/gpdmthesis.pdf">Master's
thesis</a>). This prior is unusual as it is improper, but it is not
the standard uninformative 1/x prior. This approach can be recreated
using the <code>-dh</code> flag when running the code. An alternative
approach of scaling the portion of the likelihood associated with the
dynamics up by a factor has also been suggested. This approach can be
recreated by using the <code>-ds</code> flag.</p>

<p>My own preference is to avoid either of these approaches. A key
motivation of the GP-LVM as a probabilistic model was to design an
approach that avoided difficult to justify scalings and unusual
priors. The basic problem is that if the hyper parameters are
optimised the Gaussian process is too flexible a model for application
modelling the dynamics. However it is also true that a non-linear
model is needed. As an alternative approach we suggest fixing the
hyper parameters. The level of noise can be fixed by suggesting a
signal to noise ratio. This approach has also been implemented in the
code using the <code>-dr</code> flag.</p>

<div class="highlight highlight-sh"><pre>$ ./gplvm -v 3 learn -L <span class="pl-c1">true</span> -D rbf -g 0.01 -dr 20 examples/swagger.svml swagger_dynamics.model</pre></div>

<p>where the <code>-M</code> flag sets the parameter associated with
Wang's prior. Here the dynamics GP is given a linear and an RBF
kernel. The results of the visualisation are shown below.</p>

<p></p><img src="swagger_dynamics_plot.png"> <br>Latent space for
the Swagger data with the dynamics. By constraining the GP-LVM with an
unusual prior the sequence stays continuous in latent space.

<p>This result can also be loaded into MATLAB and played using the command </p>

<div class="highlight highlight-matlab"><pre><span class="pl-k">&gt;&gt; </span>mocapResultsCppBvh(<span class="pl-s"><span class="pl-pds">'</span>swagger_dynamics.model<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>examples/Swagger.bvh<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>bvh<span class="pl-pds">'</span></span>);</pre></div>

<h1>
<a id="matlab-mex-files" class="anchor" href="#matlab-mex-files" aria-hidden="true"><span class="octicon octicon-link"></span></a>Matlab mex-files</h1>

<p>It is possible to use GPc in Matlab using a mex-file, combining the speed of
C++ and comfort of Matlab. However, there are several issues which might need
a special attention:</p>

<ul>
<li><p>when getting errors about symbols <em>defined in discarded section</em>, it
surprisingly might help to remove the Matlab interface (comment the
Matlab-related lines in your makefile.platform out);</p></li>
<li><p>when getting segmentation faults in calls to BLAS/LAPACK libraries, it might
help to compile the mex-file against MKL library instead (use -lmkl_rt instead
of -lblas -llapack).</p></li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/SheffieldML">SheffieldML</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-62971049-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
